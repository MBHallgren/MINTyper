#!/usr/bin/env python3

# Copyright (c) 2019, Malte BjÃ¸rn Hallgren Technical University of Denmark
# All rights reserved.
#

#Import Libraries

import sys
import os
import argparse
import operator
import time
import gc
import numpy as np
import array
from optparse import OptionParser
from operator import itemgetter
import re
import json
import sqlite3
import Mint3Functions as mtf
import json


parser = argparse.ArgumentParser(description='.')
parser.add_argument('-i_path_illumina', action="store", type=str, dest='i_path_illumina', default="", help='The path to the directory containing ONLY the input illumina files. Should be used when analyzing >5 read-files at a time.')
parser.add_argument('-i_path_nanopore', action="store", type=str, dest='i_path_nanopore', default="", help='The path to the directory containing ONLY the input nanopore files. Should be used when analyzing >5 read-files at a time.')
parser.add_argument("-pe", action="store_true", dest="paired_end", default = False, help="If paipred ends are used give input as True (-pe True). If Paired-ends are used, it is important that the files are written in the correct order, such as: sample1_1.fasta sample1_2.fasta sample2_1.fasta sample2_1.fasta")
parser.add_argument("-dcmMethylation", type=str, action="store", dest="dcmMethylation", default="", help="Will mask the dcmMethylation patterns matching CC[X]GG, where X will be ")
parser.add_argument("-prune", action="store_true", dest="prune", default = False, help="If set to true, all SNPs that are located within 10 bp will not be included")
parser.add_argument("-prune_distance", type=int, action="store", dest="prune_distance", default=10, help="X lenght that SNPs can be located between each other. Default is 10. If two SNPs are located within X lenght of eachother, everything between them as well as X lenght on each side of the SNPs will not be used in the alignments to calculate the distance matrix.")
parser.add_argument("-bc", action="store", type=float, default = 0.7, dest="bc", help="Base calling parameter for nanopore KMA mapping. Default is 0.7")
parser.add_argument("-db", action="store", type=str, default = "", dest="ref_kma_database", help="Comeplete path for the ref_kma_database for KMA mapping")
parser.add_argument("-thread", action="store", default = 1, dest="multi_threading", help="Set this parameter to x-number of threads that you would like to use during KMA-mapping.")
parser.add_argument("-ref", action="store", type=str, default = "", dest="reference", help="KMA will by default determine the best template against the given database. However, if you want to align your query sequences against a reference of your own choice, use this function. If this is left blank, KMA will determine the optimal reference.")
parser.add_argument('-version', action='version', version='Mint3 1.0.0', help = "current version of Mint3")
parser.add_argument("-o", action="store", dest="output_name", help="Name that you would like the output directory to be called.")
args = parser.parse_args()

def researchPipeline(i_path_illumina, i_path_nanopore, paired_end, dcmMethylation, prune, prune_distance, bc,
                     ref_kma_database, multi_threading, reference, output_name):
    if i_path_illumina == "" and i_path_nanopore == "":
        sys.exit("You did not give any input. Run the program again with an input")
    current_path = os.getcwd()
    target_dir = current_path + "/" + output_name + "/"
    cmd = "mkdir " + output_name
    os.system(cmd)
    kma_database_path = ref_kma_database
    logfilename = target_dir + "logfile_" + output_name
    logfile = open(logfilename, 'w')
    cmd = "mkdir " + target_dir + "DataFiles"
    os.system(cmd)

    # Print messages
    startTime = time.time()
    print("# Running Mint3 1.0.0 with following input conditions:", file=logfile)
    mtf.logfileConditionsResearch(logfile, dcmMethylation, prune, prune_distance, bc, ref_kma_database, multi_threading, reference, output_name, paired_end)
    if paired_end == True:
        print("# -pe", file=logfile)
    if prune == True:
        print("# -prune", file=logfile)
        print("# -prune_distance: " + str(prune_distance), file=logfile)
    if bc != 0:
        print("# -bc: " + str(bc), file=logfile)
    if ref_kma_database != "":
        print("# -db: " + ref_kma_database, file=logfile)
    if multi_threading != 1:
        print("# -thread: " + str(multi_threading), file=logfile)
    if reference != "":
        print("# -ref: " + reference, file=logfile)

    illumina_files = mtf.load_illumina(i_path_illumina)
    nanopore_files = mtf.load_nanopore(i_path_nanopore)
    complete_path_illumina_files = mtf.generate_complete_path_illumina_files(illumina_files, i_path_illumina)
    complete_path_nanopore_files = mtf.generate_complete_path_nanopore_files(nanopore_files, i_path_nanopore)
    total_filenames = mtf.combine_input_files(complete_path_illumina_files, complete_path_nanopore_files)
    best_template, templatename = mtf.findTemplateResearch(total_filenames, target_dir, kma_database_path, logfile, reference)

    if paired_end == True:
        mtf.illuminaMappingPE(complete_path_illumina_files, illumina_files, best_template, target_dir, kma_database_path, logfile, multi_threading, reference)
    else:
        mtf.illuminaMappingForward(complete_path_illumina_files, illumina_files, best_template, target_dir, kma_database_path, logfile, multi_threading, reference)
    mtf.nanoporeMapping(complete_path_nanopore_files, nanopore_files, best_template, target_dir, kma_database_path, logfile, multi_threading, bc, reference)

    if dcmMethylation != "":
        dcmstring= "-m {}".format(dcmMethylation)
    else:
        dcmstring = ""


    if prune == True:
        cmd = "ccphylo dist -i {}*.fsa -o {}{} -r \"{}\" -mc 1 -nm 0 -pr {} {} -nv {}nucleotideVarriance".format(target_dir, target_dir, "distmatrix", templatename, prune_distance, dcmstring, target_dir)

        os.system(cmd)
        print (cmd)
    
    else:
        cmd = "ccphylo dist -i {}*.fsa -o {}{} -r \"{}\" -mc 1 -nm 0 {} -nv {}nucleotideVarriance".format(target_dir, target_dir, "distmatrix",
                                                                               templatename,
                                                                               dcmstring, target_dir)
        os.system(cmd)
        print (cmd)


    """
    cmd = "ccphylo dist -i {}/*.fsa -o {}{} -r \"{}\" {} {} -nv {}nucleotideVarriance".format(target_dir, target_dir, "distmatrix",
                                                                    templatename, "-m",
                                                                    dcmMethylation, target_dir)
    os.system(cmd)
    """


    cmd = "ccphylo tree -i {}{} -o {}outtree.newick".format(target_dir, "distmatrix", target_dir)
    os.system(cmd)

    mtf.cleanUp(target_dir, illumina_files, nanopore_files, paired_end, reference)
    endTime = time.time()
    dTime = endTime - startTime
    print("Mint3 total runtime: " + str(dTime) + " seconds", file=logfile)
    logfile.close()

def main():
    researchPipeline(args.i_path_illumina, args.i_path_nanopore, args.paired_end, args.dcmMethylation, args.prune,
                     args.prune_distance, args.bc, args.ref_kma_database, args.multi_threading, args.reference, args.output_name)
if __name__== "__main__":
  main()

